# -*- coding: utf-8 -*-
# Import PyQt Widgets for PyQt5 version
from PyQt6.QtWidgets import QApplication, QMainWindow, QFileDialog
# Import pyqtSlot to connect sliders and DoubleSpinBox signals
from PyQt6.QtCore import pyqtSlot
# Import Ui_MainWindow class from UiMainApp.py generated by uic module
# from UiMainApp import Ui_MainWindow
# Import functions from numpy library for scientific simulation
from numpy import pi
import numpy as np
# Import matplotlib.cm for the color map in our image of diffraction
#import matplotlib.cm as cm

import serial

from binascii import b2a_hex, unhexlify
import time

import struct

import PyQt6
from PyQt6.QtGui import *
from PyQt6.QtWidgets import *
from PyQt6.QtCore import *
from PyQt6 import uic
from PyQt6 import QtCore
from pyqtgraph import PlotWidget, plot
import time
import pyqtgraph as pg
import sys  
import os
import crcmod

from keypad_dialog import keypadClass
import datetime

from classes import Relay
from check_port import *





print("*************磁控溅射系统****************")
print("******************************************by 周广迪")
print("******************************************from 虚空中的艾瑞量子科技")

main_uiFile = 'main_WXGA-V2.ui'



# 串口初始化
serRelay, serH700 = check_port()



# 从数据采集设备中读取所有状态
class readOnly(QThread):# QThread, emit : https://ybworld.tistory.com/110 , https://wikidocs.net/71014
    sendMainChamberVacuum_WRG = pyqtSignal(str)
    
    
    
    
    working = True
    
    
    def run(self):
        while self.working:
            if serH700 != False:
                dic_H700 = H700(serH700)

                vacuum_WRG = str(format(VacuumGauge.WideRangeGauge_Edwards(float(dic_H700["C1"])), ".2e"))
                #vacuum_CDG =
                
            else:
                vacuum_WRG = "null"
    
            self.sendMainChamberVacuum_WRG.emit(vacuum_WRG)

#print(H700(serH700))




# 自定义时间轴类
class TimeAxisItem(pg.AxisItem):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.setLabel('Time')

    def tickStrings(self, values, scale, spacing):
        return [datetime.datetime.fromtimestamp(value).strftime("%H:%M:%S") for value in values]



class MainApp(QMainWindow):
    """
    MainApp class inherit from QMainWindow and from
    Ui_MainWindow class in UiMainApp module.
    """
    def __init__(self):        
        # """Constructor or the initializer"""
        # QMainWindow.__init__(self)
        # # It is imperative to call self.setupUi (self) for the interface to initialize.
        # self.setupUi(self)  # This is defined in design.py file automatically
        # # It sets up layout and widgets that are defined
        super().__init__()
        uic.loadUi(main_uiFile, self)

        self.dig_list = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        #self.anal_list = [0,0,0,0,0,0,0,0]
        self.x_count = 0
        self.xlist = list()
        # #self.xlist4 = list()
        # self.chamber_vac_ylist = list()
        # self.low_vac_ylist = list()
        # self.ArMFC_ylist = list()

        self.log = str()
        self.log_list = list()
        
        
        
        self.UIstyle()
        self.serialPortInit()
        self.checkState()
        
        
        self.worker = readOnly()
        self.worker.sendMainChamberVacuum_WRG.connect(self.graph_MainChamberVacuum)
        
        
        self.worker.start()
        
        
        #QScroller.grabGesture(self.log_listview, QScroller.LeftMouseButtonGesture) # https://runebook.dev/ko/docs/qt/qscroller
        self.pen_blk = pg.mkPen(color=(0, 0, 0), width = 3) # https://pyqtgraph.readthedocs.io/en/latest/functions.html
        self.pen_grn = pg.mkPen(color=(0, 255, 0), width = 3)
        
        
        
      
       
############################各种阀门################################################      
        
    #点击按钮的槽，控制前级阀门
    @pyqtSlot()
    def on_foreline_valve_button_clicked(self): 
        if self.state_foreline_valve == False:
            Relay.openRelay("Y11", self.serRelay)

            self.state_foreline_valve = True
            
            self.changeForeline_valve_button()
            
        elif self.state_foreline_valve == True:
            Relay.closeRelay("Y11", self.serRelay)

            self.state_foreline_valve = False
            self.changeForeline_valve_button()

        



############### 对应UI改变
    def changeForeline_valve_button(self):
        if self.state_foreline_valve == False:
            self.foreline_valve_button.setStyleSheet(
                                        '''
                                        QPushButton{ background-color: rgb(166, 183, 189);}
                                        '''
                                        ) 
            
            self.line_18.setStyleSheet("background-color: rgb(166, 183, 189);")
            self.line_21.setStyleSheet("background-color: rgb(166, 183, 189);")
            self.line_12.setStyleSheet("background-color: rgb(166, 183, 189);")
            
            
        elif self.state_foreline_valve == True:
            self.foreline_valve_button.setStyleSheet(
                '''
                QPushButton{background-color: rgb(35, 85, 21);}
                '''
                )
            self.line_18.setStyleSheet("background-color: rgb(35, 85, 21);")
            self.line_21.setStyleSheet("background-color: rgb(35, 85, 21);")
            self.line_12.setStyleSheet("background-color: rgb(35, 85, 21);")
            
    
    ## 粗抽阀门
    
    
    
    
    
    ## 插板阀
    
    ## 旁抽阀
    
    
    ## 工艺气体导入阀门
    
    
    
    ## vent阀门 自动vent按钮控制
    
 
############################干泵的控制与动作################################################        
 
    #点击按钮的槽，控制干泵启停
    @pyqtSlot()
    def on_screw_pump_button_clicked(self):
        
        
        if self.state_screw_pump_valve == False:
            Relay.openRelay("Y32", self.serRelay)
            
            # 需要加单独的检查程序
            
            self.state_screw_pump_valve = True
            
            self.changeScrew_pump_button()
      
        
        elif self.state_screw_pump_valve == True:
            Relay.closeRelay("Y32", self.serRelay)
            
            # 需要加单独的检查程序
            
            self.state_screw_pump_valve = False
            
            self.changeScrew_pump_button()

        
    # 切换泵的远程/手动 开启
    @pyqtSlot()
    def on_actionDryPumpRemote_triggered(self):
        
        Relay.openRelay("Y30", self.serRelay)
        
        # 需要加单独的检查程序
        self.state_DryPumpRemote_valve = True #是否远程干泵
        self.changeDryPumpRemote_action()
        
    
    @pyqtSlot()    
    def on_actionDryPumpLocal_triggered(self):
        
        Relay.closeRelay("Y30", self.serRelay)
        
        # 需要加单独的检查程序
        self.state_DryPumpRemote_valve = False #是否远程干泵
        self.changeDryPumpRemote_action()
    

    # 重新设置干泵
    @pyqtSlot()    
    def on_actionDryPumpReset_triggered(self):
        #print(self.label_DryPump_remote.text())
        # try:
        original_text = self.label_DryPump_remote.text()
        # except:
        #     print(123)
        
        Relay.openRelay("Y31", self.serRelay)
        
        self.label_DryPump_remote.setText("Resetting")
        
        # 需要加单独的检查程序
        
        # 使用 QTimer 延迟恢复原始文本
        QTimer.singleShot(3000, lambda: self.label_DryPump_remote.setText(original_text))
        
        Relay.closeRelay("Y31", self.serRelay)
    

############### 对应UI改变            
    def changeScrew_pump_button(self):
        if self.state_screw_pump_valve == False:
            self.screw_pump_button.setStyleSheet(
                                        '''
                                        QPushButton{background-color: rgb(166, 183, 189);}
                                        '''
                                        ) 
            self.line_17.setStyleSheet("background-color: rgb(166, 183, 189);")
            self.line_11.setStyleSheet("background-color: rgb(166, 183, 189);")
            self.line_13.setStyleSheet("background-color: rgb(166, 183, 189);")
            self.line_123.setStyleSheet("background-color: rgb(166, 183, 189);")
            self.line_19.setStyleSheet("background-color: rgb(166, 183, 189);")
            self.line_191.setStyleSheet("background-color: rgb(166, 183, 189);")
            
        elif self.state_screw_pump_valve == True:
            self.screw_pump_button.setStyleSheet(
                                        '''
                                        QPushButton{background-color: rgb(35, 85, 21);}
                                        '''
                                        ) 
            self.line_17.setStyleSheet("background-color: rgb(35, 85, 21);")
            self.line_11.setStyleSheet("background-color: rgb(35, 85, 21);")
            self.line_13.setStyleSheet("background-color: rgb(35, 85, 21);")
            self.line_123.setStyleSheet("background-color: rgb(35, 85, 21);")
            self.line_19.setStyleSheet("background-color: rgb(35, 85, 21);")
            self.line_191.setStyleSheet("background-color: rgb(35, 85, 21);") 

    def changeDryPumpRemote_action(self):
        if self.state_DryPumpRemote_valve == False:
            self.label_DryPump_remote.setText("Local")
        elif self.state_DryPumpRemote_valve == True:
            self.label_DryPump_remote.setText("Remote")
            

##########################################################################################


##############################分子泵控制##########################################



##########################################################################################



######################################绘图、数字更新

    def graph_MainChamberVacuum(self, mainChamberVacuum):
        
        # 每过两秒检查一次所有继电器的状态
        self.last_second = None  # 记录上一次的秒数
        current_second = int(time.time()) % 60  # 获取当前秒数
        if current_second % 2 == 0 and current_second != self.last_second:
            self.checkState()  
            self.last_second = current_second  # 更新上一次的秒数
        
        # 更新全量程真空计的显示
        self.label_mainVacuumValue.setText(str(mainChamberVacuum))
        # 主腔体真空更新，全量成和薄膜规的切换
        if float(mainChamberVacuum)<0.133 or float(mainChamberVacuum) >13.3:
            self.label_mainVacuumValue2.setText(str(mainChamberVacuum) + " Pa")
            
        #elif 






        
    def serialPortInit(self): 
        if serRelay and serH700 != False:
            self.serRelay = serRelay
            self.serH700 = serH700
        else:
            sys.exit()
            
      # self.serLowVacuum = serLowVacuum
      # self.serMFCAr = serMFCAr
      # self.serDCPower = serDCPower
      # self.serForelineValve = serForelineValve
        
     

        
        
        # 调用键盘
    def keypad(self, button):
        try:
            dlg = keypadClass()
            r = dlg.showmodal()
            if r:
                text = dlg.keypad_val.text()
                #if button == "gas_inputAr":


        except:
            print("keypad error")
           # self.serMFCAr.close()
            # 退出程序，关闭UI界面
            sys.exit() 

    def LOG(self):
        now = datetime.datetime.now()
        nowDatetime = now.strftime('%Y-%m-%d %H:%M:%S ')
        self.log = nowDatetime + self.log
        self.log_listview.addItem(self.log)
        
        self.log_csv = self.log.replace(' ', ',', 2).split(',')
        self.log_list.append(self.log_csv)


#     def UIinit(self):
# #        self.power_button.clicked.connect(self.closeEvent)

# #        self.rotary_button.clicked.connect(self.rotary_clicked) 

#         self.main_button.clicked.connect(lambda:self.change_page(0))
#         self.chamber_button.clicked.connect(lambda:self.change_page(1))
#         self.chamber2_button.clicked.connect(lambda:self.change_page(1))
#         #self.loadlock_button.clicked.connect(lambda:self.change_page(1))
        
#         self.actionComm.triggered.connect(lambda:self.change_page(2))
#         self.graph_button.clicked.connect(lambda:self.change_page(3))
#         self.log_button.clicked.connect(lambda:self.change_page(4))
        
#         self.centerrun_button.clicked.connect(self.centerpowerOpen)
#         self.forelinevalve_button.clicked.connect(self.forelinevalve)

        
#         self.doubleSpinBox_growthPressure.valueChanged.connect(self.growthPressureValueChanged)



    def UIstyle(self):

        # self.rotary_button.setStyleSheet(
        #     '''
        #     QPushButton{border-width: 2px; border-radius: 10px; background-color: rgb(3, 86, 161); color: rgb(255,255,255);}
        #     QPushButton:pressed{border-width: 2px; border-radius: 10px; background-color: rgb(180 , 180, 180); color: rgb(0,0,0); }
        #     '''
        #     )
        # self.loadlockroughvalve_button.setStyleSheet(
        #     '''
        #     QPushButton{font: 16pt "Arial"; border-style: solid; border-width: 1px; border-radius: 6px; border-color: rgb(3, 86, 161); background-color: rgb(255, 255, 255); color: rgb(0,0,0);}
        #     QPushButton:pressed{border-width: 2px; border-radius: 10px; background-color: rgb(180 , 180, 180); color: rgb(0,0,0); }
        #     '''
        #     )

        self.logo_label.setPixmap(QPixmap("./pic/logo1.png"))
        
        

            



    def closeEvent(self, event):
        # 这里是你想在窗口关闭时执行的代码
        print("程序关闭，释放所有串口。")
        # 如果需要，可以在这里调用 event.ignore() 来阻止窗口关闭  
        # try:
        #     self.serMFCAr.close()
        #     self.serVacuumAll.close()
        #     self.serLowVacuum.close()
        #     self.serForelineValve.close()
        #     if self.statetDCPower == "open":
        #         self.serDCPower.close() 
               
        #     print("串口释放成功！")

        # except:
        #     print("串口释放失败！")

    # 检查所有继电器的状态
    def checkState(self):
        relay_status = Relay.checkAllState(self.serRelay)
        
        
        #### 继电器状态
        self.state_foreline_valve = relay_status["Y11"] # 前级阀门状态
        self.state_gate_valve = relay_status["Y12"] # 插板阀
        #self.state_TMP = relay_
        
        self.state_DryPumpRemote_valve = relay_status["Y30"] #是否远程干泵
        #self.state_DryPumpReset_valve = relay_status["Y31"] #reset干泵，应该无需检查状态
        self.state_screw_pump_valve = relay_status["Y32"] #干泵是否启动
        
        
        
        
        #### 根据继电器状态修改UI
        self.changeForeline_valve_button() # 根据继电器状态改变前级阀门在Ui中的显示
        self.changeScrew_pump_button()   # 根据干泵是否启动，改变干泵在UI中的显示
        self.changeDryPumpRemote_action() # 根据是否在远程控制干泵，改变远程在Ui中的显示


if __name__ == "__main__":
    import sys
    app = QApplication(sys.argv)
    MyApplication = MainApp()
    MyApplication.show()  # Show the form
    sys.exit(app.exec())  # Execute the app





